[
  {
    "id": "mqtt-broker-config",
    "type": "mqtt-broker",
    "z": "",
    "name": "Mekansm MQTT Broker",
    "broker": "mqtt.example.com",
    "port": "1883",
    "clientid": "nodered-mekansm",
    "usetls": false,
    "protocol": "mqtt",
    "keepalive": "60",
    "cleansession": true,
    "birthTopic": "mekansm/nodered/status",
    "birthQos": "0",
    "birthPayload": "connected",
    "closeTopic": "mekansm/nodered/status",
    "closeQos": "0",
    "closePayload": "disconnected",
    "willTopic": "mekansm/nodered/status",
    "willQos": "0",
    "willPayload": "offline"
  },
  {
    "id": "mqtt-subscribe-iot",
    "type": "mqtt in",
    "z": "mekansm-flow",
    "name": "Subscribe IoT Data",
    "topic": "mekansm/+/+",
    "qos": "1",
    "datatype": "auto",
    "broker": "mqtt-broker-config",
    "nl": false,
    "rap": true,
    "rh": 0,
    "x": 100,
    "y": 100,
    "wires": [["parse-device-data"]]
  },
  {
    "id": "parse-device-data",
    "type": "function",
    "z": "mekansm-flow",
    "name": "Parse Device & Data",
    "func": "// Parse MQTT topic: mekansm/device-eui/data-type\nconst topicParts = msg.topic.split('/');\nconst deviceEUI = topicParts[1];\nconst dataType = topicParts[2];\n\n// Initialize payload structure\nif (!msg.deviceData) {\n  msg.deviceData = {\n    device_eui: deviceEUI,\n    timestamp: new Date().toISOString(),\n    readings: {}\n  };\n}\n\n// Parse incoming payload\nlet value = msg.payload;\nif (typeof msg.payload === 'string') {\n  try {\n    value = JSON.parse(msg.payload);\n  } catch (e) {\n    try {\n      value = parseFloat(msg.payload);\n    } catch (e2) {\n      node.warn('Could not parse payload: ' + msg.payload);\n      return null;\n    }\n  }\n}\n\n// Store readings by type\nif (dataType === 'power' || dataType === 'consumption' || dataType === 'kwh') {\n  msg.deviceData.readings.consumption = parseFloat(value);\n} else if (dataType === 'temperature' || dataType === 'temp') {\n  msg.deviceData.readings.temperature = parseFloat(value);\n} else if (dataType === 'humidity' || dataType === 'humid') {\n  msg.deviceData.readings.humidity = parseFloat(value);\n} else if (dataType === 'voltage') {\n  msg.deviceData.readings.voltage = parseFloat(value);\n} else if (dataType === 'current') {\n  msg.deviceData.readings.current = parseFloat(value);\n} else {\n  msg.deviceData.readings[dataType] = value;\n}\n\nnode.warn('Parsed - Device: ' + deviceEUI + ', Type: ' + dataType + ', Value: ' + value);\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 300,
    "y": 100,
    "wires": [["buffer-readings"]]
  },
  {
    "id": "buffer-readings",
    "type": "function",
    "z": "mekansm-flow",
    "name": "Buffer Readings (5min)",
    "func": "// Store readings in context for buffering\nconst deviceEUI = msg.deviceData.device_eui;\nconst contextKey = 'device_' + deviceEUI;\n\n// Get existing data or create new\nlet storedData = context.get(contextKey) || {\n  device_eui: deviceEUI,\n  readings: {},\n  lastUpdate: new Date().toISOString()\n};\n\n// Merge new readings\nObject.assign(storedData.readings, msg.deviceData.readings);\nstoredData.lastUpdate = new Date().toISOString();\n\n// Store back in context (max 5 minutes)\ncontext.set(contextKey, storedData, 'default', 300); // 300 seconds = 5 minutes\n\nnode.warn('Buffered readings for ' + deviceEUI + ': ' + JSON.stringify(storedData.readings));\n\nmsg.deviceData = storedData;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 500,
    "y": 100,
    "wires": [["check-consumption-data"]]
  },
  {
    "id": "check-consumption-data",
    "type": "switch",
    "z": "mekansm-flow",
    "name": "Has consumption?",
    "property": "deviceData.readings.consumption",
    "propertyType": "msg",
    "rules": [
      {"t": "nnull"}
    ],
    "checkall": "true",
    "repair": false,
    "outputs": 1,
    "x": 700,
    "y": 100,
    "wires": [["get-device-info"]]
  },
  {
    "id": "get-device-info",
    "type": "http request",
    "z": "mekansm-flow",
    "name": "Get Device Info",
    "method": "GET",
    "ret": "obj",
    "url": "http://103.27.207.58:5000/api/v1/devices/eui/{{{deviceData.device_eui}}}",
    "tls": "",
    "persist": false,
    "authType": "basic",
    "sendrules": "",
    "headers": {},
    "x": 880,
    "y": 100,
    "wires": [["process-device-data"]],
    "timeout": 10
  },
  {
    "id": "process-device-data",
    "type": "function",
    "z": "mekansm-flow",
    "name": "Build Request Payload",
    "func": "// Extract device info from API response\nlet deviceInfo = {};\nif (msg.payload && msg.payload.success && msg.payload.data) {\n  deviceInfo = msg.payload.data;\n}\n\n// Build payload for backend API\nmsg.payload = {\n  device_eui: msg.deviceData.device_eui,\n  device_id: deviceInfo.id,\n  device_name: deviceInfo.device_name || deviceInfo.name,\n  device_type: deviceInfo.device_type || deviceInfo.type,\n  class_id: deviceInfo.class_id,\n  consumption: msg.deviceData.readings.consumption,\n  temperature: msg.deviceData.readings.temperature || null,\n  humidity: msg.deviceData.readings.humidity || null,\n  timestamp: msg.deviceData.lastUpdate\n};\n\nmsg.headers = {\n  'Content-Type': 'application/json'\n};\n\nnode.warn('Request payload: ' + JSON.stringify(msg.payload));\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1050,
    "y": 100,
    "wires": [["save-to-backend"]]
  },
  {
    "id": "save-to-backend",
    "type": "http request",
    "z": "mekansm-flow",
    "name": "Save to Backend API",
    "method": "POST",
    "ret": "obj",
    "url": "http://103.27.207.58:5000/api/v1/consumption/realtime",
    "tls": "",
    "persist": false,
    "authType": "",
    "sendrules": "",
    "headers": {},
    "x": 1250,
    "y": 100,
    "wires": [["check-response"]],
    "timeout": 10
  },
  {
    "id": "check-response",
    "type": "switch",
    "z": "mekansm-flow",
    "name": "Status OK?",
    "property": "statusCode",
    "propertyType": "msg",
    "rules": [
      {"t": "eq", "v": "201", "vt": "num"},
      {"t": "eq", "v": "200", "vt": "num"},
      {"t": "else"}
    ],
    "checkall": "true",
    "repair": false,
    "outputs": 3,
    "x": 1400,
    "y": 100,
    "wires": [["success-log"], ["success-log"], ["error-log"]]
  },
  {
    "id": "success-log",
    "type": "function",
    "z": "mekansm-flow",
    "name": "Success Handler",
    "func": "node.warn('‚úÖ Data saved - Device: ' + msg.payload.device_name + ', Consumption: ' + msg.payload.consumption + ' kW');\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1550,
    "y": 80,
    "wires": [["debug-success", "split-success-handler"]]
  },
  {
    "id": "error-log",
    "type": "function",
    "z": "mekansm-flow",
    "name": "Error Handler",
    "func": "node.error('‚ùå Failed to save data - Status: ' + msg.statusCode);\nnode.error('Response: ' + JSON.stringify(msg.payload));\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1550,
    "y": 140,
    "wires": [["debug-error"]]
  },
  {
    "id": "debug-success",
    "type": "debug",
    "z": "mekansm-flow",
    "name": "‚úÖ Success",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 1700,
    "y": 80,
    "wires": []
  },
  {
    "id": "debug-error",
    "type": "debug",
    "z": "mekansm-flow",
    "name": "‚ùå Error",
    "active": true,
    "tosidebar": true,
    "console": true,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 1700,
    "y": 140,
    "wires": []
  },
  {
    "id": "send-to-analytics",
    "type": "http request",
    "z": "mekansm-flow",
    "name": "Send to Analytics",
    "method": "POST",
    "ret": "obj",
    "url": "http://103.27.207.58:5000/api/v1/analytics/realtime",
    "tls": "",
    "persist": false,
    "authType": "",
    "sendrules": "",
    "headers": {},
    "x": 1550,
    "y": 200,
    "wires": [["debug-analytics"]],
    "timeout": 10
  },
  {
    "id": "debug-analytics",
    "type": "debug",
    "z": "mekansm-flow",
    "name": "üìä Analytics",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 1700,
    "y": 200,
    "wires": []
  },
  {
    "id": "build-analytics-payload",
    "type": "function",
    "z": "mekansm-flow",
    "name": "Build Analytics Payload",
    "func": "// Build analytics payload with all readings\nmsg.analyticsPayload = {\n  device_eui: msg.deviceData.device_eui,\n  device_id: msg.payload.device_id,\n  device_name: msg.payload.device_name,\n  timestamp: msg.deviceData.lastUpdate,\n  readings: msg.deviceData.readings,\n  metrics: {\n    consumption: msg.deviceData.readings.consumption || 0,\n    temperature: msg.deviceData.readings.temperature || null,\n    humidity: msg.deviceData.readings.humidity || null,\n    voltage: msg.deviceData.readings.voltage || null,\n    current: msg.deviceData.readings.current || null\n  }\n};\n\nmsg.headers = {\n  'Content-Type': 'application/json'\n};\n\nmsg.payload = msg.analyticsPayload;\n\nnode.warn('Analytics payload: ' + JSON.stringify(msg.analyticsPayload));\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1400,
    "y": 200,
    "wires": [["send-to-analytics"]]
  },
  {
    "id": "publish-realtime-mqtt",
    "type": "mqtt out",
    "z": "mekansm-flow",
    "name": "Publish Realtime Data",
    "topic": "mekansm/realtime/{{{deviceData.device_eui}}}",
    "qos": "1",
    "retain": false,
    "broker": "mqtt-broker-config",
    "x": 1550,
    "y": 260,
    "wires": []
  },
  {
    "id": "prepare-mqtt-publish",
    "type": "function",
    "z": "mekansm-flow",
    "name": "Prepare MQTT Publish",
    "func": "// Prepare payload for MQTT publish to other subscribers\nmsg.payload = JSON.stringify({\n  device_eui: msg.deviceData.device_eui,\n  readings: msg.deviceData.readings,\n  timestamp: msg.deviceData.lastUpdate\n});\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1400,
    "y": 260,
    "wires": [["publish-realtime-mqtt"]]
  },
  {
    "id": "split-success-handler",
    "type": "function",
    "z": "mekansm-flow",
    "name": "Success: Send to Analytics & MQTT",
    "func": "// After successful save, send to analytics and MQTT\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1300,
    "y": 220,
    "wires": [["build-analytics-payload", "prepare-mqtt-publish"]]
  },
  {
    "id": "mqtt-subscribe-commands",
    "type": "mqtt in",
    "z": "mekansm-flow",
    "name": "Subscribe Device Commands",
    "topic": "mekansm/+/command",
    "qos": "1",
    "datatype": "auto",
    "broker": "mqtt-broker-config",
    "nl": false,
    "rap": true,
    "rh": 0,
    "x": 100,
    "y": 350,
    "wires": [["parse-command"]]
  },
  {
    "id": "parse-command",
    "type": "function",
    "z": "mekansm-flow",
    "name": "Parse Device Command",
    "func": "// Parse command from MQTT\nconst topicParts = msg.topic.split('/');\nconst deviceEUI = topicParts[1];\n\nlet command = msg.payload;\nif (typeof msg.payload === 'string') {\n  try {\n    command = JSON.parse(msg.payload);\n  } catch (e) {\n    command = { action: msg.payload };\n  }\n}\n\nmsg.command = {\n  device_eui: deviceEUI,\n  action: command.action || command,\n  params: command.params || {},\n  timestamp: new Date().toISOString()\n};\n\nnode.warn('Command received - Device: ' + deviceEUI + ', Action: ' + JSON.stringify(command));\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 300,
    "y": 350,
    "wires": [["send-command-to-device"]]
  },
  {
    "id": "send-command-to-device",
    "type": "mqtt out",
    "z": "mekansm-flow",
    "name": "Send to Device",
    "topic": "mekansm/{{{command.device_eui}}}/control",
    "qos": "1",
    "retain": false,
    "broker": "mqtt-broker-config",
    "x": 500,
    "y": 350,
    "wires": []
  },
  {
    "id": "http-subscribe-commands",
    "type": "http in",
    "z": "mekansm-flow",
    "name": "POST /device/command",
    "url": "/device/command",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 100,
    "y": 450,
    "wires": [["parse-http-command"]]
  },
  {
    "id": "parse-http-command",
    "type": "function",
    "z": "mekansm-flow",
    "name": "Parse HTTP Command",
    "func": "// Parse HTTP command request\nlet body = msg.payload;\nif (typeof body === 'string') {\n  try {\n    body = JSON.parse(body);\n  } catch (e) {\n    return msg;\n  }\n}\n\nmsg.command = {\n  device_eui: body.device_eui,\n  action: body.action,\n  params: body.params || {}\n};\n\nnode.warn('HTTP Command: ' + JSON.stringify(msg.command));\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 300,
    "y": 450,
    "wires": [["publish-http-command-mqtt", "send-http-response"]]
  },
  {
    "id": "publish-http-command-mqtt",
    "type": "mqtt out",
    "z": "mekansm-flow",
    "name": "Publish Command via MQTT",
    "topic": "mekansm/{{{command.device_eui}}}/command",
    "qos": "1",
    "retain": false,
    "broker": "mqtt-broker-config",
    "x": 520,
    "y": 450,
    "wires": []
  },
  {
    "id": "http-response",
    "type": "http response",
    "z": "mekansm-flow",
    "name": "Response",
    "statusCode": "200",
    "headers": {},
    "url": "",
    "x": 720,
    "y": 450,
    "wires": []
  },
  {
    "id": "send-http-response",
    "type": "function",
    "z": "mekansm-flow",
    "name": "Build Response",
    "func": "msg.payload = {\n  success: true,\n  message: 'Command sent to device',\n  device_eui: msg.command.device_eui,\n  action: msg.command.action,\n  timestamp: new Date().toISOString()\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 550,
    "y": 500,
    "wires": [["http-response"]]
  }
]
