[
  {
    "id": "mqtt-broker-config",
    "type": "mqtt-broker",
    "z": "",
    "name": "Mekansm MQTT Broker",
    "broker": "mqtt.example.com",
    "port": "1883",
    "clientid": "nodered-mekansm",
    "usetls": false,
    "protocol": "mqtt",
    "keepalive": "60",
    "cleansession": true,
    "birthTopic": "mekansm/nodered/status",
    "birthQos": "0",
    "birthPayload": "connected",
    "closeTopic": "mekansm/nodered/status",
    "closeQos": "0",
    "closePayload": "disconnected",
    "willTopic": "mekansm/nodered/status",
    "willQos": "0",
    "willPayload": "offline"
  },
  {
    "id": "mqtt-subscribe-iot",
    "type": "mqtt in",
    "z": "mekansm-flow",
    "name": "Subscribe IoT Data",
    "topic": "mekansm/+/+",
    "qos": "1",
    "datatype": "auto",
    "broker": "mqtt-broker-config",
    "nl": false,
    "rap": true,
    "rh": 0,
    "x": 100,
    "y": 100,
    "wires": [["parse-device-data"]]
  },
  {
    "id": "parse-device-data",
    "type": "function",
    "z": "mekansm-flow",
    "name": "Parse Device & Data",
    "func": "// Parse MQTT topic: mekansm/device-eui/data-type\nconst topicParts = msg.topic.split('/');\nconst deviceEUI = topicParts[1];\nconst dataType = topicParts[2];\n\n// Initialize payload structure\nif (!msg.deviceData) {\n  msg.deviceData = {\n    device_eui: deviceEUI,\n    timestamp: new Date().toISOString(),\n    readings: {}\n  };\n}\n\n// Parse incoming payload\nlet value = msg.payload;\nif (typeof msg.payload === 'string') {\n  try {\n    value = JSON.parse(msg.payload);\n  } catch (e) {\n    try {\n      value = parseFloat(msg.payload);\n    } catch (e2) {\n      node.warn('Could not parse payload: ' + msg.payload);\n      return null;\n    }\n  }\n}\n\n// Store readings by type\nif (dataType === 'power' || dataType === 'consumption' || dataType === 'kwh') {\n  msg.deviceData.readings.consumption = parseFloat(value);\n} else if (dataType === 'temperature' || dataType === 'temp') {\n  msg.deviceData.readings.temperature = parseFloat(value);\n} else if (dataType === 'humidity' || dataType === 'humid') {\n  msg.deviceData.readings.humidity = parseFloat(value);\n} else if (dataType === 'voltage') {\n  msg.deviceData.readings.voltage = parseFloat(value);\n} else if (dataType === 'current') {\n  msg.deviceData.readings.current = parseFloat(value);\n} else {\n  msg.deviceData.readings[dataType] = value;\n}\n\nnode.warn('Parsed - Device: ' + deviceEUI + ', Type: ' + dataType + ', Value: ' + value);\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 300,
    "y": 100,
    "wires": [["buffer-readings"]]
  },
  {
    "id": "buffer-readings",
    "type": "function",
    "z": "mekansm-flow",
    "name": "Buffer Readings (5min)",
    "func": "// Store readings in context for buffering\nconst deviceEUI = msg.deviceData.device_eui;\nconst contextKey = 'device_' + deviceEUI;\n\n// Get existing data or create new\nlet storedData = context.get(contextKey) || {\n  device_eui: deviceEUI,\n  readings: {},\n  lastUpdate: new Date().toISOString()\n};\n\n// Merge new readings\nObject.assign(storedData.readings, msg.deviceData.readings);\nstoredData.lastUpdate = new Date().toISOString();\n\n// Store back in context (max 5 minutes)\ncontext.set(contextKey, storedData, 'default', 300); // 300 seconds = 5 minutes\n\nnode.warn('Buffered readings for ' + deviceEUI + ': ' + JSON.stringify(storedData.readings));\n\nmsg.deviceData = storedData;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 500,
    "y": 100,
    "wires": [["check-consumption-data"]]
  },
  {
    "id": "check-consumption-data",
    "type": "switch",
    "z": "mekansm-flow",
    "name": "Has consumption?",
    "property": "deviceData.readings.consumption",
    "propertyType": "msg",
    "rules": [
      {"t": "nnull"}
    ],
    "checkall": "true",
    "repair": false,
    "outputs": 1,
    "x": 700,
    "y": 100,
    "wires": [["get-device-info"]]
  },
  {
    "id": "get-device-info",
    "type": "http request",
    "z": "mekansm-flow",
    "name": "Get Device Info",
    "method": "GET",
    "ret": "obj",
    "url": "http://localhost:5000/api/v1/devices/eui/{{{deviceData.device_eui}}}",
    "tls": "",
    "persist": false,
    "authType": "basic",
    "sendrules": "",
    "headers": {},
    "x": 880,
    "y": 100,
    "wires": [["process-device-data"]],
    "timeout": 10
  },
  {
    "id": "process-device-data",
    "type": "function",
    "z": "mekansm-flow",
    "name": "Build Request Payload",
    "func": "// Extract device info from API response\nlet deviceInfo = {};\nif (msg.payload && msg.payload.success && msg.payload.data) {\n  deviceInfo = msg.payload.data;\n}\n\n// Build payload for backend API\nmsg.payload = {\n  device_eui: msg.deviceData.device_eui,\n  device_id: deviceInfo.id,\n  device_name: deviceInfo.device_name || deviceInfo.name,\n  device_type: deviceInfo.device_type || deviceInfo.type,\n  class_id: deviceInfo.class_id,\n  consumption: msg.deviceData.readings.consumption,\n  temperature: msg.deviceData.readings.temperature || null,\n  humidity: msg.deviceData.readings.humidity || null,\n  timestamp: msg.deviceData.lastUpdate\n};\n\nmsg.headers = {\n  'Content-Type': 'application/json'\n};\n\nnode.warn('Request payload: ' + JSON.stringify(msg.payload));\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1050,
    "y": 100,
    "wires": [["save-to-backend"]]
  },
  {
    "id": "save-to-backend",
    "type": "http request",
    "z": "mekansm-flow",
    "name": "Save to Backend API",
    "method": "POST",
    "ret": "obj",
    "url": "http://localhost:5000/api/v1/consumption/realtime",
    "tls": "",
    "persist": false,
    "authType": "",
    "sendrules": "",
    "headers": {},
    "x": 1250,
    "y": 100,
    "wires": [["check-response"]],
    "timeout": 10
  },
  {
    "id": "check-response",
    "type": "switch",
    "z": "mekansm-flow",
    "name": "Status OK?",
    "property": "statusCode",
    "propertyType": "msg",
    "rules": [
      {"t": "eq", "v": "201", "vt": "num"},
      {"t": "eq", "v": "200", "vt": "num"},
      {"t": "else"}
    ],
    "checkall": "true",
    "repair": false,
    "outputs": 3,
    "x": 1400,
    "y": 100,
    "wires": [["success-log"], ["success-log"], ["error-log"]]
  },
  {
    "id": "success-log",
    "type": "function",
    "z": "mekansm-flow",
    "name": "Success Handler",
    "func": "node.warn('✅ Data saved - Device: ' + msg.payload.data.device_name + ', Consumption: ' + msg.payload.data.consumption + ' kW');\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1550,
    "y": 80,
    "wires": [["debug-success"]]
  },
  {
    "id": "error-log",
    "type": "function",
    "z": "mekansm-flow",
    "name": "Error Handler",
    "func": "node.error('❌ Failed to save data - Status: ' + msg.statusCode);\nnode.error('Response: ' + JSON.stringify(msg.payload));\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1550,
    "y": 140,
    "wires": [["debug-error"]]
  },
  {
    "id": "debug-success",
    "type": "debug",
    "z": "mekansm-flow",
    "name": "✅ Success",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 1700,
    "y": 80,
    "wires": []
  },
  {
    "id": "debug-error",
    "type": "debug",
    "z": "mekansm-flow",
    "name": "❌ Error",
    "active": true,
    "tosidebar": true,
    "console": true,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 1700,
    "y": 140,
    "wires": []
  }
]
